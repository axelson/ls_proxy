Content-Length: 14545

{"id":5,"jsonrpc":"2.0","result":{"contents":"> GenServer\n\nA behaviour module for implementing the server of a client-server relation.\n\nA GenServer is a process like any other Elixir process and it can be used\nto keep state, execute code asynchronously and so on. The advantage of using\na generic server process (GenServer) implemented using this module is that it\nwill have a standard set of interface functions and include functionality for\ntracing and error reporting. It will also fit into a supervision tree.\n\n## Example\n\nThe GenServer behaviour abstracts the common client-server interaction.\nDevelopers are only required to implement the callbacks and functionality\nthey are interested in.\n\nLet's start with a code example and then explore the available callbacks.\nImagine we want a GenServer that works like a stack, allowing us to push\nand pop items:\n\n    defmodule Stack do\n      use GenServer\n\n      # Callbacks\n\n      @impl true\n      def init(stack) do\n        {:ok, stack}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, [head | tail]) do\n        {:reply, head, tail}\n      end\n\n      @impl true\n      def handle_cast({:push, item}, state) do\n        {:noreply, [item | state]}\n      end\n    end\n\n    # Start the server\n    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n\n    # This is the client\n    GenServer.call(pid, :pop)\n    #=> :hello\n\n    GenServer.cast(pid, {:push, :world})\n    #=> :ok\n\n    GenServer.call(pid, :pop)\n    #=> :world\n\nWe start our `Stack` by calling `start_link/2`, passing the module\nwith the server implementation and its initial argument (a list\nrepresenting the stack containing the item `:hello`). We can primarily\ninteract with the server by sending two types of messages. **call**\nmessages expect a reply from the server (and are therefore synchronous)\nwhile **cast** messages do not.\n\nEvery time you do a `GenServer.call/3`, the client will send a message\nthat must be handled by the `c:handle_call/3` callback in the GenServer.\nA `cast/2` message must be handled by `c:handle_cast/2`. There are 7 possible\ncallbacks to be implemented when you use a `GenServer`. The only required\ncallback is `init/1`.\n\n## Client / Server APIs\n\nAlthough in the example above we have used `GenServer.start_link/3` and\nfriends to directly start and communicate with the server, most of the\ntime we don't call the `GenServer` functions directly. Instead, we wrap\nthe calls in new functions representing the public API of the server.\n\nHere is a better implementation of our Stack module:\n\n    defmodule Stack do\n      use GenServer\n\n      # Client\n\n      def start_link(default) when is_list(default) do\n        GenServer.start_link(__MODULE__, default)\n      end\n\n      def push(pid, item) do\n        GenServer.cast(pid, {:push, item})\n      end\n\n      def pop(pid) do\n        GenServer.call(pid, :pop)\n      end\n\n      # Server (callbacks)\n\n      @impl true\n      def init(stack) do\n        {:ok, stack}\n      end\n\n      @impl true\n      def handle_call(:pop, _from, [head | tail]) do\n        {:reply, head, tail}\n      end\n\n      @impl true\n      def handle_cast({:push, item}, state) do\n        {:noreply, [item | state]}\n      end\n    end\n\nIn practice, it is common to have both server and client functions in\nthe same module. If the server and/or client implementations are growing\ncomplex, you may want to have them in different modules.\n\n## How to supervise\n\nA `GenServer` is most commonly started under a supervision tree.\nWhen we invoke `use GenServer`, it automatically defines a `child_spec/1`\nfunction that allows us to start the `Stack` directly under a supervisor.\nTo start a default stack of `[:hello]` under a supervisor, one may do:\n\n    children = [\n      {Stack, [:hello]}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nNote you can also start it simply as `Stack`, which is the same as\n`{Stack, []}`:\n\n    children = [\n      Stack # The same as {Stack, []}\n    ]\n\n    Supervisor.start_link(children, strategy: :one_for_all)\n\nIn both cases, `Stack.start_link/1` is alwaus invoked.\n\n`use GenServer` also accepts a list of options which configures the\nchild specification and therefore how it runs under a supervisor.\nThe generated `child_spec/1` can be customized with the following options:\n\n  * `:id` - the child specification identifier, defaults to the current module\n  * `:start` - how to start the child process (defaults to calling `__MODULE__.start_link/1`)\n  * `:restart` - when the child should be restarted, defaults to `:permanent`\n  * `:shutdown` - how to shut down the child, either immediately or by giving it time to shut down\n\nFor example:\n\n    use GenServer, restart: :transient, shutdown: 10_000\n\nSee the \"Child specification\" section in the `Supervisor` module for more\ndetailed information. The `@doc` annotation immediately preceding\n`use GenServer` will be attached to the generated `child_spec/1` function.\n\n## Name registration\n\nBoth `start_link/3` and `start/3` support the `GenServer` to register\na name on start via the `:name` option. Registered names are also\nautomatically cleaned up on termination. The supported values are:\n\n  * an atom - the GenServer is registered locally with the given name\n    using `Process.register/2`.\n\n  * `{:global, term}` - the GenServer is registered globally with the given\n    term using the functions in the [`:global` module](http://www.erlang.org/doc/man/global.html).\n\n  * `{:via, module, term}` - the GenServer is registered with the given\n    mechanism and name. The `:via` option expects a module that exports\n    `register_name/2`, `unregister_name/1`, `whereis_name/1` and `send/2`.\n    One such example is the [`:global` module](http://www.erlang.org/doc/man/global.html) which uses these functions\n    for keeping the list of names of processes and their associated PIDs\n    that are available globally for a network of Elixir nodes. Elixir also\n    ships with a local, decentralized and scalable registry called `Registry`\n    for locally storing names that are generated dynamically.\n\nFor example, we could start and register our `Stack` server locally as follows:\n\n    # Start the server and register it locally with name MyStack\n    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n\n    # Now messages can be sent directly to MyStack\n    GenServer.call(MyStack, :pop)\n    #=> :hello\n\nOnce the server is started, the remaining functions in this module (`call/3`,\n`cast/2`, and friends) will also accept an atom, or any `{:global, ...}` or\n`{:via, ...}` tuples. In general, the following formats are supported:\n\n  * a PID\n  * an atom if the server is locally registered\n  * `{atom, node}` if the server is locally registered at another node\n  * `{:global, term}` if the server is globally registered\n  * `{:via, module, name}` if the server is registered through an alternative\n    registry\n\nIf there is an interest to register dynamic names locally, do not use\natoms, as atoms are never garbage-collected and therefore dynamically\ngenerated atoms won't be garbage-collected. For such cases, you can\nset up your own local registry by using the `Registry` module.\n\n## Receiving \"regular\" messages\n\nThe goal of a `GenServer` is to abstract the \"receive\" loop for developers,\nautomatically handling system messages, supporting code change, synchronous\ncalls and more. Therefore, you should never call your own \"receive\" inside\nthe GenServer callbacks as doing so will cause the GenServer to misbehave.\n\nBesides the synchronous and asynchronous communication provided by `call/3`\nand `cast/2`, \"regular\" messages sent by functions such as `Kernel.send/2`,\n`Process.send_after/4` and similar, can be handled inside the `c:handle_info/2`\ncallback.\n\n`c:handle_info/2` can be used in many situations, such as handling monitor\nDOWN messages sent by `Process.monitor/1`. Another use case for `c:handle_info/2`\nis to perform periodic work, with the help of `Process.send_after/4`:\n\n    defmodule MyApp.Periodically do\n      use GenServer\n\n      def start_link(_) do\n        GenServer.start_link(__MODULE__, %{})\n      end\n\n      @impl true\n      def init(state) do\n        # Schedule work to be performed on start\n        schedule_work()\n\n        {:ok, state}\n      end\n\n      @impl true\n      def handle_info(:work, state) do\n        # Do the desired work here\n        ...\n\n        # Reschedule once more\n        schedule_work()\n\n        {:noreply, state}\n      end\n\n      defp schedule_work do\n        # In 2 hours\n        Process.send_after(self(), :work, 2 * 60 * 60 * 1000)\n      end\n    end\n\n## When (not) to use a GenServer\n\nSo far, we have learned that a `GenServer` can be used as a supervised process\nthat handles sync and async calls. It can also handle system messages, such as\nperiodic messages and monitoring events. GenServer processes may also be named.\n\nA GenServer, or a process in general, must be used to model runtime characteristics\nof your system. A GenServer must never be used for code organization purposes.\n\nIn Elixir, code organization is done by modules and functions, processes are not\nnecessary. For example, imagine you are implementing a calculator and you decide\nto put all the calculator operations behind a GenServer:\n\n    def add(a, b) do\n      GenServer.call(__MODULE__, {:add, a, b})\n    end\n\n    def handle_call({:add, a, b}, _from, state) do\n      {:reply, a + b, state}\n    end\n\n    def handle_call({:subtract, a, b}, _from, state) do\n      {:reply, a - b, state}\n    end\n\nThis is an anti-pattern not only because it convolutes the calculator logic but\nalso because you put the calculator logic behind a single process that will\npotentially become a bottleneck in your system, especially as the number of\ncalls grow. Instead just define the functions directly:\n\n    def add(a, b) do\n      a + b\n    end\n\n    def subtract(a, b) do\n      a - b\n    end\n\nIf you don't need a process, then you don't need a process. Use processes only to\nmodel runtime properties, such as mutable state, concurrency and failures, never\nfor code organization.\n\n## Debugging with the :sys module\n\nGenServers, as [special processes](http://erlang.org/doc/design_principles/spec_proc.html),\ncan be debugged using the [`:sys` module](http://www.erlang.org/doc/man/sys.html).\nThrough various hooks, this module allows developers to introspect the state of\nthe process and trace system events that happen during its execution, such as\nreceived messages, sent replies and state changes.\n\nLet's explore the basic functions from the\n[`:sys` module](http://www.erlang.org/doc/man/sys.html) used for debugging:\n\n  * `:sys.get_state/2` - allows retrieval of the state of the process.\n    In the case of a GenServer process, it will be the callback module state,\n    as passed into the callback functions as last argument.\n  * `:sys.get_status/2` - allows retrieval of the status of the process.\n    This status includes the process dictionary, if the process is running\n    or is suspended, the parent PID, the debugger state, and the state of\n    the behaviour module, which includes the callback module state\n    (as returned by `:sys.get_state/2`). It's possible to change how this\n    status is represented by defining the optional `c:GenServer.format_status/2`\n    callback.\n  * `:sys.trace/3` - prints all the system events to `:stdio`.\n  * `:sys.statistics/3` - manages collection of process statistics.\n  * `:sys.no_debug/2` - turns off all debug handlers for the given process.\n    It is very important to switch off debugging once we're done. Excessive\n    debug handlers or those that should be turned off, but weren't, can\n    seriously damage the performance of the system.\n  * `:sys.suspend/2` - allows to suspend a process so that it only\n    replies to system messages but no other messages. A suspended process\n    can be reactivated via `:sys.resume/2`.\n\nLet's see how we could use those functions for debugging the stack server\nwe defined earlier.\n\n    iex> {:ok, pid} = Stack.start_link([])\n    iex> :sys.statistics(pid, true) # turn on collecting process statistics\n    iex> :sys.trace(pid, true) # turn on event printing\n    iex> Stack.push(pid, 1)\n    *DBG* <0.122.0> got cast {push,1}\n    *DBG* <0.122.0> new state [1]\n    :ok\n\n    iex> :sys.get_state(pid)\n    [1]\n\n    iex> Stack.pop(pid)\n    *DBG* <0.122.0> got call pop from <0.80.0>\n    *DBG* <0.122.0> sent 1 to <0.80.0>, new state []\n    1\n\n    iex> :sys.statistics(pid, :get)\n    {:ok,\n     [\n       start_time: {{2016, 7, 16}, {12, 29, 41}},\n       current_time: {{2016, 7, 16}, {12, 29, 50}},\n       reductions: 117,\n       messages_in: 2,\n       messages_out: 0\n     ]}\n\n    iex> :sys.no_debug(pid) # turn off all debug handlers\n    :ok\n\n    iex> :sys.get_status(pid)\n    {:status, #PID<0.122.0>, {:module, :gen_server},\n     [\n       [\n         \"$initial_call\": {Stack, :init, 1},            # process dictionary\n         \"$ancestors\": [#PID<0.80.0>, #PID<0.51.0>]\n       ],\n       :running,                                        # :running | :suspended\n       #PID<0.80.0>,                                    # parent\n       [],                                              # debugger state\n       [\n         header: 'Status for generic server <0.122.0>', # module status\n         data: [\n           {'Status', :running},\n           {'Parent', #PID<0.80.0>},\n           {'Logged events', []}\n         ],\n         data: [{'State', [1]}]\n       ]\n     ]}\n\n## Learn more\n\nIf you wish to find out more about GenServers, the Elixir Getting Started\nguide provides a tutorial-like introduction. The documentation and links\nin Erlang can also provide extra insight.\n\n  * [GenServer - Elixir's Getting Started Guide](https://elixir-lang.org/getting-started/mix-otp/genserver.html)\n  * [`:gen_server` module documentation](http://www.erlang.org/doc/man/gen_server.html)\n  * [gen_server Behaviour - OTP Design Principles](http://www.erlang.org/doc/design_principles/gen_server_concepts.html)\n  * [Clients and Servers - Learn You Some Erlang for Great Good!](http://learnyousomeerlang.com/clients-and-servers)\n\n","range":{"end":{"character":13,"line":13},"start":{"character":4,"line":13}}}}

